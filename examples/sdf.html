<html>
<head>

<script type="text/javascript" src="../lib/maths.js"></script>
<script type="text/javascript" src="../lib/graphics.js"></script>
<script type="text/javascript" src="../lib/camera.js"></script>
<script type="text/javascript" src="../lib/scene.js"></script>
<script type="text/javascript" src="../lib/sceneObjects.js"></script>
<script type="text/javascript" src="../lib/brdf.js"></script>
<script type="text/javascript" src="../lib/ui.js"></script>
<script type="text/javascript" src="../lib/embeddedDrawing.js"></script>

	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
	<link rel="stylesheet" href="styles.css">
</head>


<body style="width:750px; margin:0 auto">

	<div id="controls_sdf" style="width: 100%;"></div>
	<p />
	<div id="embeddedDrawing_sdf" style="width: 100%; padding-bottom: 100%;"></div>

	<pre style="display:none;">
		<script>
		(function ()
		{
			var embeddedObj = new EmbeddedDrawing("embeddedDrawing_sdf");
			var scene = embeddedObj.getScene();
			var gridSize = 16;
			var showBigCircles = false;
			var showInputShape = true;
			var showApproxShape = true;
			var followMouse = false;
			var threshold = 0.1;

			var circles = [];
			var shape = undefined;
			var approxShape = undefined;

			function init()
			{
				var gridSizeSlider = new Slider(4, 32, gridSize, 1, function (value)
				{
					gridSize = value;
					update();
				});

				var thresholdSlider = new Slider(0.1, 2, threshold, 0.1, function (value)
				{
					threshold = value;
					update();
				});

				var allowBigCirclesTick = new TickBox(showBigCircles, function (value)
				{
					showBigCircles = value;
					adjustCircles();
				});

				var showInputShapeTick = new TickBox(showInputShape, function (value)
				{
					showInputShape = value;
					update();
				});

				var showApproxShapeTick = new TickBox(showApproxShape, function (value)
				{
					if (approxShape != undefined)
						approxShape.toggleVisibility();

					embeddedObj.draw();
				});

				var followMouseTick = new TickBox(followMouse, function (value)
				{
					followMouse = value;
					update();
				});

				var controls = new PropertyGrid(document.getElementById("controls_sdf"));
				controls.addProperty("Grid Size", gridSizeSlider);
				controls.addProperty("Approximation Threshold", thresholdSlider);
				controls.addProperty("Show Big Circles", allowBigCirclesTick);
				controls.addProperty("Show Input Shape", showInputShapeTick);
				controls.addProperty("Show Approximation", showApproxShapeTick);
				controls.addProperty("Move shape with mouse", followMouseTick);
			}

			function makeGrid()
			{
				scene.deleteAllObjects();

				var rectObj = new Rectangle(new Vector(0,0));
				rectObj.points[0] = new Vector(0, 0);
				rectObj.points[1] = new Vector(32, 0);
				rectObj.points[2] = new Vector(32, 32);
				rectObj.points[3] = new Vector(0, 32);
				rectObj.color = "#73d8f9";
				rectObj.rows = gridSize;
				rectObj.columns = gridSize;
				rectObj.onChange();
				scene.addObject(rectObj);

				circles = [];

				for (var y=0; y<gridSize; ++y)
				{
					for (var x=0; x<gridSize; ++x)
					{
						var ngon = new NGon(new Vector((x+0.5)/gridSize*32, (y+0.5)/gridSize*32), 16/gridSize);
						ngon.sideCount = 60;
						ngon.color = "#df9526";
						ngon.fillColor = "#000000";
						ngon.fillAlpha = 0;
						ngon.width = 2;
						scene.addObject(ngon);
						circles.push(ngon);
					}
				}

				embeddedObj.zoomExtents();
			}

			function makeShape()
			{
				if (shape != undefined)
				{
					scene.deleteObjects([shape]);
				}

				shape = new Line([new Vector(4, 4), new Vector(8, 26), new Vector(16, 30), new Vector(24, 26), new Vector(28, 4), new Vector(24, 4), new Vector(22, 16), new Vector(10, 16), new Vector(8, 4)]);
				shape.closed = true;
				shape.color = "rgba(38, 132, 43, " + (showInputShape ? 1 : 0.4) + ")";
				shape.fillColor = "#000000";
				shape.fillAlpha = showInputShape ? 0.2 : 0;
				shape.dashed = showInputShape ? false : true;
				scene.addObject(shape);
				embeddedObj.zoomExtents();
			}

			function adjustCircles()
			{
				if (shape == undefined)
					return;

				var centroid = avg(shape.getBoundsMin(), shape.getBoundsMax());

				for (var i=0; i!=circles.length; ++i)
				{
					var c = circles[i].center;
					var rayDir = sub(centroid, c).unit();

					var intersections = [];
					var minRadius = 1000;

					for (var p=0; p!=shape.points.length; ++p)
					{
						var closestP = lineClosestPoint(c, shape.points[p], shape.points[(p+1) % shape.points.length]);

						var radius = sub(closestP, c).length();
						minRadius = Math.min(minRadius, radius);

						var hitResult = intersectRayLine(c, rayDir, shape.points[p], shape.points[(p+1) % shape.points.length]);
						if (hitResult.hit)
						{
							if (intersections.length==0 || sub(intersections[intersections.length-1], hitResult.P).length()>0.01)
								intersections.push(hitResult.P);
						}
					}

					var inside = intersections.length % 2 == 1;

					if (minRadius <= 1.414*16/gridSize)
					{
						circles[i].radius = minRadius;
						circles[i].color = "rgba(223,149,38, 1)";
						circles[i].fillAlpha = inside ? 0.5 : 0;
					}
					else
					{
						circles[i].radius = minRadius;
						circles[i].color = "rgba(223,149,38, " + (showBigCircles ? 1 : 0) + ")";
						circles[i].fillAlpha = inside ? (showBigCircles ? 0.5 : 0.01) : 0;
					}
				}

				embeddedObj.draw();
			}

			function makeApproxShape()
			{
				if (approxShape != undefined)
					scene.deleteObjects([approxShape]);

				var pixelSize = embeddedObj.camera.scale(32);

				var pixels = [];

				for (var py=0; py<pixelSize; ++py)
				{
					for (var px=0; px<pixelSize; ++px)
					{
						var wx = px / pixelSize * gridSize;
						var wy = (1 - py / pixelSize) * gridSize;

						var ix = Math.floor(wx);
						var iy = Math.floor(wy);

						var fx = wx - ix;
						var fy = wy - iy;

						if (fx<0.5)	
							ix -= 1;

						if (fy<0.5)
							iy -= 1;

						fx = wx - ix - 0.5;
						fy = wy - iy - 0.5;

						var value = 0;

						if (wx>0.5 && wx<gridSize-0.5 && wy>0.5 && wy<gridSize-0.5)
						{
							for (var j=0; j!=2; ++j)
							{
								for (var i=0; i!=2; ++i)
								{
									var height = circles[(iy+j)*gridSize + (ix+i)].radius * (circles[(iy+j)*gridSize + (ix+i)].fillAlpha>0 ? -1 : 1);

									var weight = 1;

									weight *= (i==0) ? (1-fx) : fx;
									weight *= (j==0) ? (1-fy) : fy;

									value += weight * height;
								}
							}

							value *= 0.25;
						}
						else
						{
							value = 1;
						}


						value = 1-Math.min(1, Math.max(0, Math.abs(value/threshold)));

						pixels.push(0);
						pixels.push(0);
						pixels.push(0);
						pixels.push(value * 255);
					}
				}


				approxShape = new Bitmap(new Vector(0,32), pixelSize, pixelSize, pixels);
				approxShape.drawWidth = 32;
				approxShape.drawHeight = 32;
				scene.addObject(approxShape);
				embeddedObj.draw();
			}

			embeddedObj.onMouseMove = function (m, mp)
			{
				if (shape == undefined || !followMouse)
					return;

				shape.setOrigin(m);

				adjustCircles();
			}

			function update()
			{
				makeGrid();
				makeShape();
				adjustCircles();
				makeApproxShape();
			}

			init();
			update();

		})();
		</script>
	</pre>

</body>
</html>
