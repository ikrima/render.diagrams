<html>
<head>

<script type="text/javascript" src="../lib/maths.js"></script>
<script type="text/javascript" src="../lib/graphics.js"></script>
<script type="text/javascript" src="../lib/camera.js"></script>
<script type="text/javascript" src="../lib/scene.js"></script>
<script type="text/javascript" src="../lib/sceneObjects.js"></script>
<script type="text/javascript" src="../lib/brdf.js"></script>
<script type="text/javascript" src="../lib/ui.js"></script>
<script type="text/javascript" src="../lib/embeddedDrawing.js"></script>

	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
	<link rel="stylesheet" href="../styles.css">
</head>


<body style="width:750px; margin:0 auto">

	<pre style="display:none;"><script>
	function ShowSDF(divName, controlsDivName, showGrid, showCircles, showBigCircles, showInputShape, showApproxShape, showInterpolation)
	{
		var embeddedObj = new EmbeddedDrawing(divName);
		var scene = embeddedObj.getScene();
		var gridSize = 16;
		var showGrid = showGrid;
		var showCircles = showCircles;
		var showBigCircles = showBigCircles;
		var showInputShape = showInputShape;
		var showApproxShape = showApproxShape;
		var showInterpolation = showInterpolation;
		var dragOffset = 0;
		var threshold = 0.032;

		var grid = undefined;
		var circles = [];
		var shape = undefined;
		var approxShape = undefined;

		function init()
		{
			var gridSizeSlider = new Slider(4, 32, gridSize, 1, function (value)
			{
				gridSize = value;
				update();
			});

			var thresholdSlider = new LogSlider(-3, 2, 10, threshold, 0.25, function (value)
			{
				threshold = value;
				update();
			});

			var showGridTick = new TickBox(showGrid, function (value)
			{
				showGrid = value;

				embeddedObj.setRedrawOnChange(false);

				if (grid.isVisible() != showGrid)
					grid.toggleVisibility();

				embeddedObj.setRedrawOnChange(true);
				embeddedObj.draw();
			});

			var showCirclesTick = new TickBox(showCircles, function (value)
			{
				showCircles = value;

				embeddedObj.setRedrawOnChange(false);

                for (var i=0; i!=circles.length; ++i)
                {
                    if (circles[i].isVisible() != showCircles)
                        circles[i].toggleVisibility();
                }

				embeddedObj.setRedrawOnChange(true);
				embeddedObj.draw();
			});

			var allowBigCirclesTick = new TickBox(showBigCircles, function (value)
			{
				showBigCircles = value;
				adjustCircles();
			});

			var showInputShapeTick = new TickBox(showInputShape, function (value)
			{
				showInputShape = value;

				embeddedObj.setRedrawOnChange(false);

                if (shape.isVisible() != showInputShape)
                    shape.toggleVisibility();

				embeddedObj.setRedrawOnChange(true);
				embeddedObj.draw();
			});

			var showApproxShapeTick = new TickBox(showApproxShape, function (value)
			{
				showApproxShape = value;

				if (approxShape != undefined)
				{
					if (approxShape.isVisible() != value)
						approxShape.toggleVisibility();

					embeddedObj.draw();
				}
				else
				{
					update();
				}
			});

			var showInterpolationTick = new TickBox(showInterpolation, function (value)
			{
				showInterpolation = value;
				embeddedObj.draw();
			});
			

			if (controlsDivName != undefined)
			{
				var controls = new PropertyGrid(document.getElementById(controlsDivName));
				controls.addProperty("Grid Size", gridSizeSlider);
				controls.addProperty("Approximation Threshold", thresholdSlider);
				controls.addProperty("Show Grid", showGridTick);
				controls.addProperty("Show Circles", showCirclesTick);
				controls.addProperty("Show Big Circles", allowBigCirclesTick);
				controls.addProperty("Show Input Shape", showInputShapeTick);
				controls.addProperty("Show Approximation", showApproxShapeTick);
				controls.addProperty("Show Interpolation", showInterpolationTick);
			}
		}

		function makeGrid()
		{
			embeddedObj.setRedrawOnChange(false);

			scene.deleteAllObjects();

			grid = new Rectangle(new Vector(0,0));
			grid.points[0] = new Vector(0, 0);
			grid.points[1] = new Vector(32, 0);
			grid.points[2] = new Vector(32, 32);
			grid.points[3] = new Vector(0, 32);
			grid.color = "#73d8f9";
			grid.rows = gridSize;
			grid.columns = gridSize;
			grid.onChange();
			scene.addObject(grid);

			if (!showGrid)
				grid.toggleVisibility();

			circles = [];

			for (var y=0; y<gridSize; ++y)
			{
				for (var x=0; x<gridSize; ++x)
				{
					var ngon = new NGon(new Vector((x+0.5)/gridSize*32, (y+0.5)/gridSize*32), 16/gridSize);
					ngon.sideCount = 60;
					ngon.color = "#df9526";
					ngon.fillColor = "#000000";
					ngon.fillAlpha = 0;
					ngon.width = 2;
					scene.addObject(ngon);
					circles.push(ngon);

					if (!showCircles)
						ngon.toggleVisibility();
				}
			}

			embeddedObj.setRedrawOnChange(true);
			embeddedObj.zoomExtents();
		}

		function makeShape()
		{
			if (shape != undefined)
			{
				embeddedObj.setRedrawOnChange(false);
				scene.deleteObjects([shape]);
				embeddedObj.setRedrawOnChange(true);
			}

			shape = new Line([new Vector(4, 4), new Vector(8, 26), new Vector(16, 30), new Vector(24, 26), new Vector(28, 4), new Vector(24, 4), new Vector(22, 16), new Vector(10, 16), new Vector(8, 4)]);
			shape.closed = true;
			shape.color = "rgba(38, 132, 43, 1)";
			shape.fillColor = "#000000";
			shape.fillAlpha = 0.2;
			scene.addObject(shape);

			if (!showInputShape)
				shape.toggleVisibility();

			embeddedObj.zoomExtents();
		}

		function adjustCircles()
		{
			if (shape == undefined)
				return;

			var centroid = new Vector(1.123,2.456);//avg(shape.getBoundsMin(), shape.getBoundsMax());

			for (var i=0; i!=circles.length; ++i)
			{
				var c = circles[i].center;
				var rayDir = sub(centroid, c).unit();

				var intersections = [];
				var minRadius = 1000;

				for (var p=0; p!=shape.points.length; ++p)
				{
					var closestP = lineClosestPoint(c, shape.points[p], shape.points[(p+1) % shape.points.length]);

					var radius = sub(closestP, c).length();
					minRadius = Math.min(minRadius, radius);

					var hitResult = intersectRayLine(c, rayDir, shape.points[p], shape.points[(p+1) % shape.points.length]);
					if (hitResult.hit)
					{
						if (intersections.length==0 || sub(intersections[intersections.length-1], hitResult.P).length()>0.01)
							intersections.push(hitResult.P);
					}
				}

				var inside = intersections.length % 2 == 1;

				if (minRadius <= 1.414*16/gridSize)
				{
					circles[i].radius = minRadius;
					circles[i].color = "rgba(223,149,38, 1)";
					circles[i].fillAlpha = inside ? 0.5 : 0;
				}
				else
				{
					circles[i].radius = minRadius;
					circles[i].color = "rgba(223,149,38, " + (showBigCircles ? 1 : 0) + ")";
					circles[i].fillAlpha = inside ? (showBigCircles ? 0.5 : 0.00001) : 0;
				}
			}

			embeddedObj.draw();
		}

		function makeApproxShape()
		{
			if (!showApproxShape)
			{
				if (approxShape != undefined)
				{
					embeddedObj.setRedrawOnChange(false);
					scene.deleteObjects([approxShape]);
					embeddedObj.setRedrawOnChange(true);
				}

				return;
			}

			var pixelSize = Math.floor(embeddedObj.camera.scale(32));

			var pixels = new Array(pixelSize*pixelSize*4);

			var index = 0;

			for (var py=0; py<pixelSize; ++py)
			{
				for (var px=0; px<pixelSize; ++px)
				{
					var wx = px / pixelSize * gridSize;
					var wy = (1 - py / pixelSize) * gridSize;

					var ix = Math.floor(wx);
					var iy = Math.floor(wy);

					var fx = wx - ix;
					var fy = wy - iy;

					if (fx<0.5)
						ix -= 1;

					if (fy<0.5)
						iy -= 1;

					fx = wx - ix - 0.5;
					fy = wy - iy - 0.5;

					var value = 0;

					for (var j=0; j!=2; ++j)
					{
						for (var i=0; i!=2; ++i)
						{
							var height = 100;

							if ((ix+i)>=0 && (ix+i)<gridSize)
							{
								if ((iy+j)>=0 && (iy+j)<gridSize)
								{
									height = circles[(iy+j)*gridSize + (ix+i)].radius * (circles[(iy+j)*gridSize + (ix+i)].fillAlpha>0 ? -1 : 1);
								}
							}

							var weight = 1;

							weight *= (i==0) ? (1-fx) : fx;
							weight *= (j==0) ? (1-fy) : fy;

							value += weight * height;
						}
					}

					value *= 0.25;

					value = 1-Math.min(1, Math.max(0, Math.abs(value/threshold)));

					pixels[index+0] = 0;
					pixels[index+1] = 0;
					pixels[index+2] = 0;
					pixels[index+3] = value * 255;
					index += 4;
				}
			}

			//embeddedObj.setRedrawOnChange(false);

			if (approxShape == undefined)
			{
				approxShape = new Bitmap(new Vector(0,32), pixelSize, pixelSize, pixels);
				approxShape.drawWidth = 32;
				approxShape.drawHeight = 32;
				scene.addObject(approxShape);
			}
			else
			{
				approxShape.setPixelData(pixelSize, pixelSize, pixels);
			}

			//embeddedObj.setRedrawOnChange(true);

			embeddedObj.draw();
		}

		embeddedObj.onMouseMove = function (m, mp, buttons)
		{
			if (shape == undefined)
				return;

			if (buttons & 2)
			{
				shape.setOrigin(add(m, dragOffset));
				adjustCircles();
				makeApproxShape();
			}

			if (showInterpolation)
			{
				var wx = m.x / 32 * gridSize;
				var wy = m.y / 32 * gridSize;

				var ix = Math.floor(wx);
				var iy = Math.floor(wy);

				var fx = wx - ix;
				var fy = wy - iy;

				if (fx<0.5)
					ix -= 1;

				if (fy<0.5)
					iy -= 1;

				fx = wx - ix - 0.5;
				fy = wy - iy - 0.5;

				var value = 0;

				for (var j=0; j!=2; ++j)
				{
					for (var i=0; i!=2; ++i)
					{
						var height = 100;

						if ((ix+i)>=0 && (ix+i)<gridSize)
						{
							if ((iy+j)>=0 && (iy+j)<gridSize)
							{
								height = circles[(iy+j)*gridSize + (ix+i)].radius * (circles[(iy+j)*gridSize + (ix+i)].fillAlpha>0 ? -1 : 1);
							}
						}

						var weight = 1;

						weight *= (i==0) ? (1-fx) : fx;
						weight *= (j==0) ? (1-fy) : fy;

						value += weight * height;
					}
				}

				value *= 0.25;

				value = 1-Math.min(1, Math.max(0, Math.abs(value/threshold)));

				if (ix>=0 && ix<gridSize-1)
				{
					if (iy>=0 && iy<gridSize-1)
					{
						embeddedObj.camera.drawRectangle(sub(circles[(iy+0)*gridSize + (ix+0)].getOrigin(), new Vector(1,1)), add(circles[(iy+1)*gridSize + (ix+1)].getOrigin(), new Vector(1,1)), "10FF10", 2, [5,5]);

						embeddedObj.camera.drawArrow(circles[(iy+0)*gridSize + (ix+0)].getOrigin(), new Vector(m.x, circles[(iy+0)*gridSize + (ix+0)].getOrigin().y), 10, "#10FF10", 2);
						embeddedObj.camera.drawArrow(circles[(iy+0)*gridSize + (ix+1)].getOrigin(), new Vector(m.x, circles[(iy+0)*gridSize + (ix+1)].getOrigin().y), 10, "#10FF10", 2);

						embeddedObj.camera.drawArrow(circles[(iy+1)*gridSize + (ix+0)].getOrigin(), new Vector(m.x, circles[(iy+1)*gridSize + (ix+0)].getOrigin().y), 10, "#10FF10", 2);
						embeddedObj.camera.drawArrow(circles[(iy+1)*gridSize + (ix+1)].getOrigin(), new Vector(m.x, circles[(iy+1)*gridSize + (ix+1)].getOrigin().y), 10, "#10FF10", 2);

						embeddedObj.camera.drawArrow(new Vector(m.x, circles[(iy+0)*gridSize + (ix+0)].getOrigin().y), m, 10, "#10FF10", 2);
						embeddedObj.camera.drawArrow(new Vector(m.x, circles[(iy+1)*gridSize + (ix+0)].getOrigin().y), m, 10, "#10FF10", 2);
					}
				}
			}
		}

		embeddedObj.onMouseDown = function (m, mp, buttons)
		{
			if (shape == undefined)
				return;

			dragOffset = sub(shape.getOrigin(), m);
		}

		function update()
		{
			makeGrid();
			makeShape();
			adjustCircles();
			makeApproxShape();
		}

		init();
		update();

	}
	</script></pre>

	A <a href="https://en.wikipedia.org/wiki/Signed_distance_function" rel="noopener" target="_blank">Signed Distance Field</a> is a mathematical construct where the distance to a closed surface is computed along a set of positions, with the sign of the distance used to indicate whether the position is inside or outside the surface. The positions are typically chosen to be on a regular grid and they work well in both 2D and 3D. They were made popular in computer graphics by this SIGGRAPH 2007 <a href="http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf" rel="noopener" target="_blank">paper</a> by Valve. If you haven't already read it, it's definitely worth a read!

	In this post we'll investigate using a simple 2D SDF to approximate a shape. It's by no means the only use of SDF, but it's one that's easy to visualize and has practical use in computer graphics.

	We'll start with the surface shown below. It's a closed surface so that we can tell whether a point is inside or outside its perimeter.

	<div id="embeddedDrawing_sdf_shape" style="width: 70%; padding-bottom: 70%; margin:0 auto;"></div>

	<pre style="display:none;"><script>
		ShowSDF("embeddedDrawing_sdf_shape", undefined, false, false, false, true, false);
	</script></pre>

	Next, we'll overlay a regular grid over the surface. As you might expect, the size of the grid is important, the finer it is, the better the approximation will be.

	<div id="embeddedDrawing_sdf_grid" style="width: 70%; padding-bottom: 70%; margin:0 auto;"></div>

	<pre style="display:none;"><script>
		ShowSDF("embeddedDrawing_sdf_grid", undefined, true, false, false, true, false);
	</script></pre>

	For each grid cell, we can calculate the distance of the cell center to the nearest point of the surface. We'll represent that with a circle. We'll also indicate whether the cell center is inside the shape or not by coloring in the circle. Note that we only store one value per cell, calculated at its center, so while a cell may overlap the surface boundary, we only care about its center.

	Go ahead and move the shape around (right mouse drag) to see how the cell distance values change.

	<div id="embeddedDrawing_sdf_circle" style="width: 70%; padding-bottom: 70%; margin:0 auto;"></div>

	<pre style="display:none;"><script>
		ShowSDF("embeddedDrawing_sdf_circle", undefined, true, true, false, true, false);
	</script></pre>

	Note that for reasons of clarity I'm only showing the circles that have a diameter of about one cell. The other cells are computed as well and their values will be used later on for the approximation.

	Ok, so now we have a regular grid where we store the distance to the shape boundary as well as a bit that tells us whether we're inside or outside the shape. How can we use that information to reconstruct the original shape?

	Let's have a look at the diagram without the original shape.

	<div id="embeddedDrawing_sdf_circles_only" style="width: 70%; padding-bottom: 70%; margin:0 auto;"></div>

	<pre style="display:none;"><script>
		ShowSDF("embeddedDrawing_sdf_circles_only", undefined, true, true, false, false, false);
	</script></pre>

	Imagine we throw a dart onto the grid. If the dart lands exactly at the center of a cell we'll accurately know our distance to the shape outline and whether we're inside it or not. That information will only be accurate if it lands exactly at the center because that's where we evaluated the distance and sign. If the dart lands anywhere else (and chances are that it will) then we'll need to make an approximation by interpolating between the 4 nearest cells.

	<div id="controls_sdf" style="width: 100%;"></div>
	<p />
	<div id="embeddedDrawing_sdf2" style="width: 100%; padding-bottom: 100%;"></div>
	<pre style="display:none;"><script>
		ShowSDF("embeddedDrawing_sdf2", "controls_sdf", true, true, false, true, true);
	</script></pre>

	* does the surface need to be closed?
	* do we need to store sign?
	* cross section height diagram
	* hardware does the interpolation for us
	* generating is expensive, sampling is cheap


</body>
</html>
