<html>
<head>

<script type="text/javascript" src="../lib/maths.js"></script>
<script type="text/javascript" src="../lib/graphics.js"></script>
<script type="text/javascript" src="../lib/camera.js"></script>
<script type="text/javascript" src="../lib/ui.js"></script>
<script type="text/javascript" src="../lib/scene.js"></script>
<script type="text/javascript" src="../lib/sceneObjects.js"></script>
<script type="text/javascript" src="../lib/brdf.js"></script>
<script type="text/javascript" src="../lib/embeddedDrawing.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>

	<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css" />
	<link rel="stylesheet" href="http://renderdiagrams.org/wp-content/themes/structural/style.css" />
	<link rel="stylesheet" href="../styles.css" />
</head>


<body style="width:750px; margin:0 auto">

	<pre style="display:none;"><script>

			function ShowVisibilityExample(divName, controlsDivName, polar, convolution)
			{
				var embeddedObj=new EmbeddedDrawing(divName);
				var scene=embeddedObj.getScene();
				var camera=embeddedObj.camera;
				var functionGraph=undefined;
				var textObject = undefined;

				var doConvolution = convolution;

				function addControls()
				{
					if(controlsDivName==undefined)
					return;

					var convolutionControl = new TickBox(doConvolution, function (value) { doConvolution = value; functionGraph.doConvolution = value; functionGraph.onChange(); });

					var controls=new PropertyGrid(document.getElementById(controlsDivName));
					controls.addProperty("Apply Convolution", convolutionControl);
				}

				function makeScene()
				{
					scene.deleteAllObjects();

					embeddedObj.setDragUsingCtrl();
					embeddedObj.enableGridSnap(false);

					var w=new Wall([new Vector(-5.5,14),new Vector(-8.5,12),new Vector(-10.5,14),new Vector(-8.5,17),new Vector(-5.5,16)]);
					w.closed=true;
					w.roughness=0;
					w.metalness=0;
					w.intensity=1;
					w.BRDFIndex=1;
					w.appearance.lineWidth=1;
					w.appearance.lineRGB[0]=0;
					w.appearance.lineRGB[1]=0;
					w.appearance.lineRGB[2]=0;
					w.appearance.lineAlpha=1;
					w.appearance.lineDashIndex=0;
					w.appearance.fillRGB[0]=127;
					w.appearance.fillRGB[1]=127;
					w.appearance.fillRGB[2]=127;
					w.appearance.fillAlpha=0.2;
					w.visible=true;
					w.frozen=false;
					w.onChange();
					scene.addObject(w);

					var w=new Wall([new Vector(2.5,17),new Vector(-0.5,15),new Vector(-2.5,17),new Vector(-0.5,20),new Vector(2.5,19)]);
					w.closed=true;
					w.roughness=0;
					w.metalness=0;
					w.intensity=1;
					w.BRDFIndex=1;
					w.appearance.lineWidth=1;
					w.appearance.lineRGB[0]=0;
					w.appearance.lineRGB[1]=0;
					w.appearance.lineRGB[2]=0;
					w.appearance.lineAlpha=1;
					w.appearance.lineDashIndex=0;
					w.appearance.fillRGB[0]=127;
					w.appearance.fillRGB[1]=127;
					w.appearance.fillRGB[2]=127;
					w.appearance.fillAlpha=0.2;
					w.visible=true;
					w.frozen=false;
					w.onChange();
					scene.addObject(w);

					var w=new Wall([new Vector(11,10),new Vector(8,8),new Vector(6,10),new Vector(8,13),new Vector(11,12)]);
					w.closed=true;
					w.roughness=0;
					w.metalness=0;
					w.intensity=1;
					w.BRDFIndex=1;
					w.appearance.lineWidth=1;
					w.appearance.lineRGB[0]=0;
					w.appearance.lineRGB[1]=0;
					w.appearance.lineRGB[2]=0;
					w.appearance.lineAlpha=1;
					w.appearance.lineDashIndex=0;
					w.appearance.fillRGB[0]=127;
					w.appearance.fillRGB[1]=127;
					w.appearance.fillRGB[2]=127;
					w.appearance.fillAlpha=0.2;
					w.visible=true;
					w.frozen=false;
					w.onChange();
					scene.addObject(w);

					var w=new Wall([new Vector(-9.5,-3),new Vector(-12.5,-5),new Vector(-14.5,-3),new Vector(-12.5,0),new Vector(-9.5,-1)]);
					w.closed=true;
					w.roughness=0;
					w.metalness=0;
					w.intensity=1;
					w.BRDFIndex=1;
					w.appearance.lineWidth=1;
					w.appearance.lineRGB[0]=0;
					w.appearance.lineRGB[1]=0;
					w.appearance.lineRGB[2]=0;
					w.appearance.lineAlpha=1;
					w.appearance.lineDashIndex=0;
					w.appearance.fillRGB[0]=127;
					w.appearance.fillRGB[1]=127;
					w.appearance.fillRGB[2]=127;
					w.appearance.fillAlpha=0.2;
					w.visible=true;
					w.frozen=false;
					w.onChange();
					scene.addObject(w);

					var w=new Wall([new Vector(3,-7),new Vector(0,-9),new Vector(-2,-7),new Vector(0,-4),new Vector(3,-5)]);
					w.closed=true;
					w.roughness=0;
					w.metalness=0;
					w.intensity=1;
					w.BRDFIndex=1;
					w.appearance.lineWidth=1;
					w.appearance.lineRGB[0]=0;
					w.appearance.lineRGB[1]=0;
					w.appearance.lineRGB[2]=0;
					w.appearance.lineAlpha=1;
					w.appearance.lineDashIndex=0;
					w.appearance.fillRGB[0]=127;
					w.appearance.fillRGB[1]=127;
					w.appearance.fillRGB[2]=127;
					w.appearance.fillAlpha=0.2;
					w.visible=true;
					w.frozen=false;
					w.onChange();
					scene.addObject(w);

					var w=new Wall([new Vector(17,-2),new Vector(14,-4),new Vector(12,-2),new Vector(14,1),new Vector(17,0)]);
					w.closed=true;
					w.roughness=0;
					w.metalness=0;
					w.intensity=1;
					w.BRDFIndex=1;
					w.appearance.lineWidth=1;
					w.appearance.lineRGB[0]=0;
					w.appearance.lineRGB[1]=0;
					w.appearance.lineRGB[2]=0;
					w.appearance.lineAlpha=1;
					w.appearance.lineDashIndex=0;
					w.appearance.fillRGB[0]=127;
					w.appearance.fillRGB[1]=127;
					w.appearance.fillRGB[2]=127;
					w.appearance.fillAlpha=0.2;
					w.visible=true;
					w.frozen=false;
					w.onChange();
					scene.addObject(w);

					functionGraph=new FunctionGraph(new Vector(0,0));
					functionGraph.appearance.lineWidth=2;
					functionGraph.appearance.lineRGB[0]=66;
					functionGraph.appearance.lineRGB[1]=134;
					functionGraph.appearance.lineRGB[2]=244;
					functionGraph.appearance.lineAlpha=1;
					functionGraph.appearance.lineDashIndex=0;
					functionGraph.appearance.fillRGB[0]=255;
					functionGraph.appearance.fillRGB[1]=127;
					functionGraph.appearance.fillRGB[2]=0;
					functionGraph.appearance.fillAlpha=0.5;
					functionGraph.functionStr=unescape("//%20Type%20your%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09x%3A%20%5BCartesian%5D%20The%20value%20on%20the%20X%20axis%20on%20which%20the%20function%20needs%20to%20be%20evaluated%20at.%0A//%20%09x%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20which%20the%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20%09hitDistance%3A%20%5BCartesian%5D%20A%20ray%20is%20shot%20along%20the%20Y%20axis%2C%20starting%20at%20each%20evaluation%20position.%0A//%20%09hitDistance%3A%20%5BPolar%5D%20A%20ray%20is%20shot%20for%20each%20evaluation%20direction.%0A//%09%09%09%09%09%20%20%20%20%20If%20it%20hits%20something%2C%20hitDistance%20containts%20the%20distance%20to%20the%20hit.%0A//%09%09%09%09%09%20%20%20%20%20If%20it%20doesn%27t%20hit%20anything%2C%20it%27s%20set%20to%20undefined.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20function%20for%20the%20specified%20input.%0A%0Areturn%20hitDistance%20%3F%200%20%3A%205%3B");
					functionGraph.convolutionFunctionStr = unescape("//%20Type%20your%20convolution%20function%20here%2C%20using%20valid%20JavaScript.%0A//%0A//%20Parameters%3A%0A//%20%09dx%3A%20%5BCartesian%5D%20The%20distance%20along%20the%20X%20axis%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.//%20%09dx%3A%20%5BPolar%5D%20The%20angle%2C%20in%20radians%2C%20from%20the%20center%20value%20that%20the%20convolution%20function%20needs%20to%20be%20evaluated%20at.%0A//%0A//%20Expected%20Return%3A%0A//%20%09A%20single%20number%20%28scalar%20float%29%20that%20is%20the%20evalution%20of%20the%20convolution%20function%20for%20the%20specified%20input.%0A%0Areturn%20Math.max%280%2C%20Math.cos%28dx%29%29%3B");
					functionGraph.coordinateType=polar? 1:0;
					functionGraph.xAxis=new Vector(1,0);
					functionGraph.xMin=polar? 0:-15;
					functionGraph.xMax=polar? Math.PI*2:19;
					functionGraph.evalStep=polar? 1*Math.PI/180:0.25;
					functionGraph.xLabel=2;
					functionGraph.showXAxis=!polar;
					functionGraph.xLabelStep=1;
					functionGraph.xLabelDecimals=0;
					functionGraph.xGridlines=false;
					functionGraph.yLabel=2;
					functionGraph.showYAxis=true;
					functionGraph.yLabelStep=1;
					functionGraph.yLabelDecimals=0;
					functionGraph.yGridlines=false;
					functionGraph.evaluateOnMouseCursor=false;
					functionGraph.doConvolution=doConvolution;
					functionGraph.doRayCasting=true;
					functionGraph.yLimitMin=-5;
					functionGraph.yLimitMax=7;
					functionGraph.graphOriginLocal=new Vector(0,0);
					functionGraph.visible=true;
					functionGraph.frozen=false;
					functionGraph.onChange();
					scene.addObject(functionGraph);

					var text = new Text(new Vector(0, 12), unescape("Drag%20mouse%20here%21"));
					text.halign = "1";
					text.valign = "1";
					text.font = "Arial";
					text.fontSize = 2;
					text.appearance.lineWidth = 3;
					text.appearance.lineRGB[0] = 255;
					text.appearance.lineRGB[1] = 64;
					text.appearance.lineRGB[2] = 0;
					text.appearance.lineAlpha = 1;
					text.appearance.lineDashIndex = 0;
					text.appearance.fillRGB[0] = 127;
					text.appearance.fillRGB[1] = 127;
					text.appearance.fillRGB[2] = 127;
					text.appearance.fillAlpha = 0;
					text.angle = 0;
					text.lineSpacing = 1.6;
					text.visible = true;
					text.frozen = false;
					text.maxWidth = 8.279567824469673;
					text.totalHeight = 1.3324648539225261;
					scene.addObject(text);
					textObject = text;

				}

				embeddedObj.onMouseMove=function(m,mp,buttons,ctrlKey,shiftKey)
				{
					embeddedObj.setRedrawOnChange(false);

					if (textObject!=undefined)
					{
						textObject.toggleVisibility(0);
					}

					if ( (buttons&1) && !ctrlKey )
					{
						functionGraph.setOrigin(m);
					}

					embeddedObj.setRedrawOnChange(true);

					return false;
				}

				embeddedObj.onMouseLeave=function()
				{
					embeddedObj.draw();
				}

				embeddedObj.onFrameTick = function(deltaTime_ms, accumulatedTime_ms)
				{
					if (textObject.isVisible())
					{
						textObject.fontSize = lerp(2, 2.2, (Math.sin(accumulatedTime_ms / 1000 * Math.PI * 2) * 0.5 + 0.5));
						textObject.onChange();
					}
				}

				addControls();
				makeScene();
				embeddedObj.zoomExtents();
			}

</script></pre>

	The Function Graph object in the editor allows you to plot cartesian and polar graphs of arbitrary functions. Since the functions are authored in Javascript, it's actually quite easy to add logic and more or less arbitrary code to them, i.e. we're not restricted to stricly maths-like functions. One of the advantages of this is that it was quite easy to expose ray hit testing results as inputs to the functions. This has allowed for some quite interesting graphs!
	<!--more-->
	<h3>Ray Casting</h3>
	For the Function Graph object the user supplied function is evaluated once for each value on the X axis. The framework passes the the x value of the evaluation as the 'x' parameter of the fuction. Using the same approach we can pass all sorts of data to the user function, for example the results of a ray cast.

	At each evaluation position we fire off a ray into the scene. For polar graphs the ray starts at the center of the graph and is shot along the evaluation direction. For cartesian graphs the ray starts at the evaluation point on the X axis and it's shot along the direction of the Y Axis. The results of the raycasting are made available via the '<code>hitDistance</code>' argument that is now passed to the user function. If the ray doesn't hit any scene geometry then <code>hitDistance</code> is set to <code>undefined</code>.

	From a rendering perspective, the obvious use case for this functionality is to create a visibility function. Let's see an example of this. Use Mouse Drag to move the function graph around.

	<div id="embeddedDrawing_visibility_example_cartesian" style="width: 70%; padding-bottom: 70%; margin:0 auto 1em;"></div>

	<pre style="display:none;"><script>
	ShowVisibilityExample("embeddedDrawing_visibility_example_cartesian");
	</script></pre>

	The code for this function was simply this:
	[code language="javascript"]
	return hitDistance ? 0 : 5;[/code]

	If the <code>hitDistance</code> parameter is set to something (in this example it doesn't matter how far away the collision was) we return zero, otherwise we return 5. In other words, we're making a graph that has non-zero values whererever it's unobstructed.

	Of course it makes more sense to present this as a polar graph! See how the graph changes as you move the origin around the scene (use mouse drag to move).

	<div id="embeddedDrawing_visibility_example_polar" style="width: 70%; padding-bottom: 70%; margin:0 auto 1em;"></div>
	
	<pre style="display:none;"><script>
	ShowVisibilityExample("embeddedDrawing_visibility_example_polar",undefined,true);
	</script></pre>

	<h3>Lighting Equation</h3>
	With ray casting results available to us, we're very close to being able to do some nice things! The previous graph has a non-zero value where the 'view' of the world in that direction is unobstructed. We use this as the visibility term of the <a href="https://en.wikipedia.org/wiki/Rendering_equation" target="_blank" rel="noopener" title="Wikipedia link">Lighting Equation</a>:
	$$L_o = \int_\Omega \mathit{f}_r(i,o) L(i) V(i)(\overline{n \cdot i}) d\omega$$

	where:
	<ul>
	<li> \(L_o\) The light being reflected along direction \(o\)
	<li> \(\int_\Omega\) An integral over the hemisphere
	<li> \(\mathit{f}_r(i,o)\) The BRDF at point of interest evaluated for incoming direction \(i\) on the hemisphere and for outgoing direction \(o\).
	<li> \(L(i)\) The amount of lighting arriving at the point of interest along direction \(i\).
	<li> \(V(i)\) The visibility factor for direction \(i\), i.e. if our view of the light coming in from direction \(i\) obstructed?
	<li> \((\overline{n \cdot i})\) dot product between surface normal n and light direction \(i\), clamped to zero.
	</ul>

	Let's simplify this equation a little by assuming a pure Lambert BRDF (i.e. \(\mathit{f}_r(i,o) = \frac{\rho}{\pi}\)) and a constant lighting envinronment, \(L(i) = 1\). This leaves us with just the following:
	$$L_o = \frac{\rho}{\pi}\int_\Omega V(i)(\overline{n \cdot i}) d\omega$$

	which is effectively a convolution of the visibility function with clamped cosine lobe.

	As it happens, the Function Graph objects in the <a href="https://renderdiagrams.org/editor.html" target="_blank" rel="noopener">editor</a> now support <a href="https://renderdiagrams.org/2019/02/17/introduction-to-convolution-integrals/" target="_blank" rel="noopener">convolution integrals</a>, which is quite handy because it means we can visualise this simplified lighting equation!

	We'll have the base function be just the visibility term:

	[code language="javascript"]
	return hitDistance ? 0 : 5;[/code]

	and we'll add a convolution function to represent the integration with the clamped cosine lobe, \((\overline{n \cdot i})\):

	[code language="javascript"]
	return Math.max(0, Math.cos(dx));[/code]

	<div id="controls_visibility_cosine_lobe" style="width: 70%; margin:0 auto;"></div>
	<div id="embeddedDrawing_visibility_cosine_lobe" style="width: 70%; padding-bottom: 70%; margin:0 auto 1em;"></div>
	
	<pre style="display:none;"><script>
	ShowVisibilityExample("embeddedDrawing_visibility_cosine_lobe", "controls_visibility_cosine_lobe", true, true);
	</script></pre>

</body>
</html>
